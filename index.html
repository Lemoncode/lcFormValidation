<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>LcFormValidation</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/prism.css">
    <link rel="stylesheet" href="css/styles.css">
  </head>
  <body data-spy="scroll" data-target=".scrollspy">
    <div class="container">
      <div class="row">
        <header id="header" class="jumbotron text-center">
          <h1>LcFormValidation</h1>
          <p>A framework agnostic, async form validation library</p>
        </header>
        <main class="col-md-9">
          <section id="introduction">
            <article>
              <h1 class="heading">
                <span>Introduction</span>
                <a href="#introduction">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h1>
              <p>LcFormValidation is a form validation library:</p>
              <ul class="arrow-styled">
                <li>Heavily based on JavaScript (no HTML attributes or classes)</li>
                <li>Full async, all validations are processed as async.</li>
              </ul>
            </article>
            <article id="why">
              <h3 class="heading">
                <span>Why another validation library?</span>
                <a href="#why">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                Form validation is a complex issue, usually we can find solutions that cover the simple scenarios and are focused on building
                RAD development just by adding some attributes / annotations to given fields or HTML fields (e.g. input),
                the disadvantage that we have found to this approach:
              </p>
              <ul>
                <li>
                  There are different approaches for each scenario: sometimes you have to add some tweaking for async validations, some other
                  take care of special scenarios (like validations that depends on more than one field).
                </li>
                <li>
                  Usually you can easily unit test one validation (directive / annotation), but testing the whole form is a complex task (directives
                  are coupled to e.g. HTML).
                </li>
                <li>
                  Validations are tightly coupled to e.g. directives or markup is not easy to reuse this validation code in e.g. server side
                  (universal JavaScript application).
                </li>
              </ul>
            </article>
            <article id="approach">
              <h3 class="heading">
                <span>LcFormValidation approach</span>
                <a href="#approach">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The idea is to encapsulate all the common functionality in a base class, and create independent classes that will inherit
                from this base class to implement the validation of each individual form.
              </p>
              <pre class="snippets"><code class="language-js"></code></pre>
              <p>By following this approach:</p>
              <ul>
                <li>
                  We encapsulate all the generic validation plumbing in a base class. We can implement real world form validation in the specific
                  classes.
                </li>
                <li>
                  We can benefit from external validation libraries (validate emails, url, iban ...), without having to implement additional
                  scaffolding (e.g. create a directive for this validation).
                </li>
                <li>
                  We can easily test:
                  <ul>
                    <li>The FormValidation</li>
                    <li>Each specific form validation class.</li>
                    <li>The generic validator helpers.</li>
                  </ul>
                  <li>
                    We can just run this JavaScript code in the client and server side (e.g. node solution)
                  </li>
                </li>
              </ul>
            </article>
          </section>
          <section id="download">
            <h1 class="heading">
              <span>Download</span>
              <a href="#download">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <div class="row">
              <div class="col-md-6">
                <div>
                  <a role="button" class="btn btn-large btn-primary">lc-form-validation</a>
                </div>
              </div>
              <div class="col-md-6">

              </div>
            </div>
          </section>
          <section id="installation">
            <h1 class="heading">
              <span>Installation</span>
              <a href="#installation">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <article>
              <h3>npm</h3>
              <pre>npm install --save lc-form-validation</pre>
            </article>
          </section>
          <section id="get-started">
            <h1 class="heading">
              <span>Get started</span>
              <a href="#get-started">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <article>
              <div>
                [[INTRODUCTION]]
              </div>
            </article>
            <article id="FormValidation">
              <h3 class="heading">
                <span>FormValidation</span>
                <a href="#FormValidation">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              [[FORMVALIDATION]]
            </article>
            <article id="ValidationConstraints">
              <h3 class="heading">
                <span>ValidationConstraints</span>
                <a href="#ValidationConstraints">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              [[VALIDATIONCONSTRAINTS]]
            </article>
          </section>
          <section id="validators">
            <h1 class="heading">
              <span>Validators</span>
              <a href="#validators">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <p>LcFormValidation includes a set of basic validation rules you can use. You can also write
              <a href="#custom-validators">your own validator functions</a> if you need some specific domain validators.</p>
            <article id="validators-required">
              <h3 class="heading">
                <span>Validators.required</span>
                <a href="#validators-required">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>required</strong> validator will check the valuse is not a empty value. This validator is useful
                when you need a fulfilled text field or check a radio or checkbox button. These values are considered empty:
                <ul>
                  <li><code>null</code></li>
                  <li><code>undefined</code></li>
                  <li><code>false</code></li>
                  <li>Empty string <code>""</code></li>
                  <li>Whitespace only string <code>" "</code> (it can be disabled with <code>customParams.trim</code> set to
                    <code><strong>false</strong></code>).</li>
                </ul>
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';
const validationConstraints = {
  fields: {
    firstname: [
      {
        validator: Validators.required,
        eventsFilter: { onChange: true, onSubmit: true }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'firstname', 'John', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'REQUIRED'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'firstname', '', { onSubmit: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'REQUIRED'
    console.log(validationResult.errorMessage);
    // 'Please fill in this mandatory field.'
  });
                </code></pre>
            </article>
            <article id="validators-minLength">
              <h3 class="heading">
                <span>Validators.minLength</span>
                <a href="#validators-minLength">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>minLength</strong> validator will check if the length of the string passed as value is equals
                or greater than the length supplied in <code>customParams.length</code>.
              </p>
              <p>
                Note: empty values such <code>null</code> or <code>undefined</code> will be marked as valid values. If you
                need to check for non-empty values you may use this validator along with
                <a href="#validators-required">required</a> validator.
              </p>
              <p>
                <strong>Important!</strong> You must always provide<code>customParams.length</code> and it must be a number.
                In case it is not provided an error will be thrown in the <code>catch</code> block of the returned promise.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const validationConstraints = {
  fields: {
    username: [
      {
        validator: Validators.minLength,
        customParams: { length : 4 },
        eventsFilter: { onChange: true }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'username', 'jasmine', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'MIN_LENGTH'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'username', 'jax', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'MIN_LENGTH'
    console.log(validationResult.errorMessage);
    // 'The value provided must have at least 4 characters.'
  });</code></pre>
            </article>
            <article id="validators-maxLength">
              <h3 class="heading">
                <span>Validators.maxLength</span>
                <a href="#validators-maxLength">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>maxLength</strong> validator will check if the length of the string passed as value is lesser
                or equals than the length supplied in <code>customParams.length</code>.
              </p>
              <p>
                Note: empty values such <code>null</code> or <code>undefined</code> will be marked as valid values. If you
                need to check for non-empty values you may use this validator along with
                <a href="#validators-required">required</a> validator.
              </p>
              <p>
                <strong>Important!</strong> You must always provide<code>customParams.length</code> and it must be a number.
                In case it is not provided an error will be thrown in the <code>catch</code> block of the returned promise.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const validationConstraints = {
  fields: {
    password: [
      {
        validator: Validators.maxLength,
        customParams: { length : 8 },
        eventsFilter: { onChange: true }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'password', 'test1234', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'MAX_LENGTH'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'password', 'toolongp@s$w0rd', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'MAX_LENGTH'
    console.log(validationResult.errorMessage);
    // 'The value provided is too long. Length must not exceed 8 characters.'
  });
                </code></pre>
            </article>
            <article id="validators-pattern">
              <h3 class="heading">
                <span>Validators.pattern</span>
                <a href="#validators-pattern">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>pattern</strong> validator will check if the value matches a regular expresion given in <code>customParams.pattern</code>                option. This regular expression can be either a
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>                instance or a string. It's important to mention that <code><strong>flags</strong></code> in string patterns
                are not supported.
              </p>
              <p>
                If you need flags in string patterns you can use the
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp constructor</a>.
              </p>
              <p>
                <strong>Important!</strong> You must always provide<code>customParams.pattern</code>. In case it is not provided
                an error will be thrown in the <code>catch</code> block of the returned promise.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const CODE_PATTERN = /^LC\d{3}$/; // or "^LC\d{3}$"
const validationConstraints = {
  fields: {
    code: [
      {
        validator: Validators.pattern,
        customParams: { pattern: CODE_PATTERN },
        eventsFilter: { onChange: true }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'code', 'LC001', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'PATTERN'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'code', '003a', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'PATTERN'
    console.log(validationResult.errorMessage);
    // 'Please provide a valid format.'
  });</code></pre>
            </article>
            <article id="validators-email">
              <h3 class="heading">
                <span>Validators.email</span>
                <a href="#validators-email">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The email validator will check if the given string value is a valid email address. LcFormValidation's email validator uses
                a RegExp provided by <a href="//emailregex.com">emailregex.com</a> that follows RFC 5322
                Official Standard since email address validation is hard to implement and there is not an unique source of
                truth. If this email validator doesn't meet your requirements you can write your
                <a href="#custom-validators">custom validator</a>.
              </p>
              <p>
                Note: empty values such <code>null</code> or <code>undefined</code> will be marked as valid values. If you
                need to check for non-empty values you may use this validator along with
                <a href="#validators-required">required</a> validator.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const validationConstraints = {
  fields: {
    email: [
      {
        validator: Validators.email,
        eventsFilter: { onChange: true }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'email', 'johndoe@example.com', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'EMAIL'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'email', 'invalidValue', { onChange: true })
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'EMAIL'
    console.log(validationResult.errorMessage);
    // 'Please enter a valid email address.'
  });</code></pre>
            </article>
            <article id="custom-validators">
              <h3 class="heading">
                <span>Implementing a custom validation</span>
                <a href="#custom-validators">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
            </article>
          </section>
          <section id="changelog">
            <h3 class="heading">
              <span>Change Log</span>
              <a href="#changelog">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h3>
          </section>
        </main>
        <aside class="col-md-3">
          <nav class="main-menu hidden-sm hidden-xs scrollspy" data-toggle="affix" data-spy="affix" data-offset-top="240">
            <ul class="nav">
              <li>
                <a href="#introduction">Introduction</a>
                <ul class="nav">
                  <li><a href="#why">Why LcFormValidation</a></li>
                  <li><a href="#approach">Approach</a></li>
                </ul>
              </li>
              <li><a href="#download">Download</a></li>
              <li><a href="#installation">Installation</a></li>
              <li>
                <a href="#get-started">Get started</a>
                <ul class="nav">
                  <li><a href="#FormValidation">FormValidation</a></li>
                  <li><a href="#ValidationConstraints">ValidationConstraints</a></li>
                </ul>
              </li>
              <li>
                <a href="#validators">Validators</a>
                <ul class="nav">
                  <li><a href="#validators-required">required</a></li>
                  <li><a href="#validators-minLength">minLength</a></li>
                  <li><a href="#validators-maxLength">maxLength</a></li>
                  <li><a href="#validators-pattern">pattern</a></li>
                  <li><a href="#validators-email">email</a></li>
                  <li><a href="#custom-validators">Custom validator</a></li>
                </ul>
              </li>
              <li> <a href="#changelog">Change Log</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prism.js" async></script>
    <script src="js/index.js"></script>
  </body>
</html>
