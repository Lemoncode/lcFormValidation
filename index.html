<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>LcFormValidation</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/prism.css">
    <link rel="stylesheet" href="css/styles.css">
  </head>
  <body data-spy="scroll" data-target=".scrollspy">
    <div class="container">
      <div class="row">
        <header id="header" class="jumbotron text-center">
          <h1>LcFormValidation</h1>
          <p>A framework agnostic, async form validation library</p>
        </header>
        <main class="col-md-9">
          <section id="introduction">
            <article>
              <h1 class="heading">
                <span>Introduction</span>
                <a href="#introduction">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h1>
              <p>LcFormValidation is a form validation library:</p>
              <ul class="arrow-styled">
                <li>Heavily based on JavaScript (no HTML attributes or classes)</li>
                <li>Full async, all validations are processed as async.</li>
              </ul>
            </article>
            <article id="why">
              <h3 class="heading">
                <span>Why another validation library?</span>
                <a href="#why">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                Form validation is a complex issue, usually we can find solutions that cover the simple scenarios and are focused on building
                RAD development just by adding some attributes / annotations to given fields or HTML fields (e.g. input),
                the disadvantage that we have found to this approach:
              </p>
              <ul>
                <li>
                  There are different approaches for each scenario: sometimes you have to add some tweaking for async validations, some other
                  take care of special scenarios (like validations that depends on more than one field).
                </li>
                <li>
                  Usually you can easily unit test one validation (directive / annotation), but testing the whole form is a complex task (directives
                  are coupled to e.g. HTML).
                </li>
                <li>
                  Validations are tightly coupled to e.g. directives or markup is not easy to reuse this validation code in e.g. server side
                  (universal JavaScript application).
                </li>
              </ul>
            </article>
            <article id="approach">
              <h3 class="heading">
                <span>LcFormValidation approach</span>
                <a href="#approach">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The idea is to encapsulate all the common functionality in a base class, and create independent classes that will inherit
                from this base class to implement the validation of each individual form.
              </p>
              <pre class="snippet"><code class="language-js"></code></pre>
              <p>By following this approach:</p>
              <ul>
                <li>
                  We encapsulate all the generic validation plumbing in a base class. We can implement real world form validation in the specific
                  classes.
                </li>
                <li>
                  We can benefit from external validation libraries (validate emails, url, iban ...), without having to implement additional
                  scaffolding (e.g. create a directive for this validation).
                </li>
                <li>
                  We can easily test:
                  <ul>
                    <li>The FormValidation</li>
                    <li>Each specific form validation class.</li>
                    <li>The generic validator helpers.</li>
                  </ul>
                  <li>
                    We can just run this JavaScript code in the client and server side (e.g. node solution)
                  </li>
                </li>
              </ul>
            </article>
          </section>
          <section id="download">
            <h1 class="heading">
              <span>Download</span>
              <a href="#download">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <div class="row">
              <div class="col-md-12 download">
                <div class="col-md-4">
                  <a role="button" class="btn btn-primary btn-block">v1.0.0 minified version</a>
                </div>
              </div>
              <div class="col-md-12 download">
                <div class="col-md-4">
                  <a role="button" class="btn btn-default btn-block">v1.0.0 development version</a>
                </div>
              </div>
            </div>
          </section>
          <section id="installation">
            <h1 class="heading">
              <span>Installation</span>
              <a href="#installation">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <article>
              <h4>Using Requited.js/AMD</h4>
              <pre class="snippet"><code class="language-js">require(['lc-form-validation'], function(lcFormValidation) {
  // ...
}</code></pre>
            </article>
            <article>
              <h4>Using ES6 modules</h4>
              <pre class="snippet"><code class="language-js">const { createFormValidation } = require('lc-form-validation');

// harmony syntax:
import { createFormValidation } from 'lc-form-validation';
</code></pre>
            </article>
            <article>
              <h4>Using script tag</h4>
              <pre class="snippet"><code class="language-jsx">&lt;script&gt;
  var createFormValidation = window['lc-form-validation'].createFormValidation;
&lt;/script&gt;</code></pre>
            </article>
          </section>
          <section id="get-started">
            <h1 class="heading">
              <span>Get started</span>
              <a href="#get-started">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <article id="overview">
              <h2 class="heading">
                <span>Overview</span>
                <a href="#overview">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h2>
              <p>Let's say we want to add validation support for a login form with a required login:</p>
              <figure>
                <img src="img/loginForm.png" alt="Login form" class="img-responsive">
              </figure>
              <p>To implement the form validation you just only need an object literal declaring a field validation constraint
                with an attached validator.</p>
              <pre class="snippet"><code class="language-js">// validation constraints declaration
const validationConstraints = {
  fields: {
    login: [
      { validator: Validators.email }
    ]
  }
};

// create a form validation instance
const formValidation = createFormValidation(validationConstraints);

// Apply wherever you need the validation result (e.g. on form submit)
function onSave(viewModel) {
  // viewModel can contain: { login: 'johndoe@example.com', password: 'jdoe123' }
  formValidation
    .validateForm(viewModel)
    .then(validationResult => {
      if(validationResult.succeeded) {
        // we can now send it to server to validate credentials
      } else {
        // display validation errors on UI
        displayFormErrors(validationResult);
      }
    })
    .catch(error => {
      // Oops, an error happened...
      handleError(error.message);
    });
}</code></pre>
            </article>
            <article id="validation-constraint">
              <h3 class="heading">
                <span>Validation constraint</span>
                <a href="#validation-constraint">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The validation constraints object is just an object literal passed with two main properties:
              </p>
              <h4><strong>fields</strong></h4>
              <p>
                An object containing all fields keys that need validations. Each field will have an array of FieldValidationConstraint objects,
                each one with three properties:
              </p>
              <ul>
                <li>
                  <code>validator</code> A function that will validate the field and return a
                  <a href="#FieldValidationResult">FieldValidationResult</a> or a promise wrapping it if the validator is
                  async
                </li>
                <li>
                  <code>eventsFilter</code> <strong>(optional)</strong> An object containing one o more event names, that
                  will be used as a filter when the validator needs to be triggered on a specific event, and a boolean value
                  poiting out . The default value of: <code>{ onChange: true }</code>;
                </li>
                <li>
                  <code>customParams</code> <strong>(optional)</strong> An object with some values needed by the validator
                  (e.g. a date format).
                </li>
              </ul>
              <pre class="snippet"><code class="language-js">fields: {
  &lt;fieldName&gt;: [
    {
      validator: &lt;validatorFunction&gt;, // function(value, viewModel, customParams)
      eventsFilter: {
        &lt;eventName&gt;: &lt;boolean&gt;,
        ...
      },
      customParams: { ... }
    }
  ]
}</code></pre>
              <h4><strong>global</strong></h4>
              <p>
                The global property will hold an array of validation functions that will validate the entire viewModel:
                <pre class="snippet"><code class="language-js">global: [
  &lt;globalValidatorFunction&gt;, // function(viewModel)
  ...
]</code></pre>
              </p>
            </article>
            <article id="validating-form">
              <h3 class="heading">
                <span>Validating form</span>
                <a href="#validating-form">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                In order to validate a single field or the entire form you have to use the methods
                <a href="#validateField">validateField</a> and <a href="#validateForm">validateForm</a> of the instance returned
                by <code>createFormValidation</code> described in the <a href="#api">API</a> section.
              </p>
            </article>
            <article id="field-validation">
              <h3 class="heading">
                <span>Field validation</span>
                <a href="#field-validation">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              [[FIELDVALIDATION]]
            </article>
          </section>
          <section id="validators">
            <h1 class="heading">
              <span>Validators</span>
              <a href="#validators">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <p>LcFormValidation includes a set of basic validation rules you can use. You can also write
              <a href="#custom-validators">your own validator functions</a> if you need some specific domain validators.</p>
            <article id="validators-required">
              <h3 class="heading">
                <span>Validators.required</span>
                <a href="#validators-required">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>required</strong> validator will check the value is not empty. This validator is useful when
                you need a fulfilled text field or a radio / checkbox button marked. These values are considered empty:
                <ul>
                  <li><code>null</code></li>
                  <li><code>undefined</code></li>
                  <li><code>false</code></li>
                  <li>Empty string <code>""</code></li>
                  <li>Whitespace only string <code>" "</code> (it can be disabled with <code>customParams.trim</code> set to
                    <code><strong>false</strong></code>).</li>
                </ul>
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';
const validationConstraints = {
  fields: {
    firstname: [
      { validator: Validators.required }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'firstname', 'John')
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'REQUIRED'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'firstname', '')
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'REQUIRED'
    console.log(validationResult.errorMessage);
    // 'Please fill in this mandatory field.'
  });</code></pre>
            </article>
            <article id="validators-minLength">
              <h3 class="heading">
                <span>Validators.minLength</span>
                <a href="#validators-minLength">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>minLength</strong> validator will check if the length of the string passed as value is equals
                or greater than the length supplied in <code>customParams.length</code>.
              </p>
              <p>
                Note: empty values such <code>null</code> or <code>undefined</code> will be marked as valid values. If you
                need to check for non-empty values you may use this validator along with
                <a href="#validators-required">required</a> validator.
              </p>
              <p>
                <strong>Important!</strong> You must always provide<code>customParams.length</code> and it must be a number.
                In case it is not provided an error will be thrown in the <code>catch</code> block of the returned promise.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const validationConstraints = {
  fields: {
    username: [
      {
        validator: Validators.minLength,
        customParams: { length : 4 }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'username', 'jasmine')
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'MIN_LENGTH'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'username', 'jax')
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'MIN_LENGTH'
    console.log(validationResult.errorMessage);
    // 'The value provided must have at least 4 characters.'
  });</code></pre>
            </article>
            <article id="validators-maxLength">
              <h3 class="heading">
                <span>Validators.maxLength</span>
                <a href="#validators-maxLength">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>maxLength</strong> validator will check if the length of the string passed as value is lesser
                or equals than the length supplied in <code>customParams.length</code>.
              </p>
              <p>
                Note: empty values such <code>null</code> or <code>undefined</code> will be marked as valid values. If you
                need to check for non-empty values you may use this validator along with
                <a href="#validators-required">required</a> validator.
              </p>
              <p>
                <strong>Important!</strong> You must always provide<code>customParams.length</code> and it must be a number.
                In case it is not provided an error will be thrown in the <code>catch</code> block of the returned promise.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const validationConstraints = {
  fields: {
    password: [
      {
        validator: Validators.maxLength,
        customParams: { length : 8 }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'password', 'test1234')
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'MAX_LENGTH'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'password', 'loooooongp@s$w0rd')
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'MAX_LENGTH'
    console.log(validationResult.errorMessage);
    // 'The value provided is too long. Length must not exceed 8 characters.'
  });</code></pre>
            </article>
            <article id="validators-pattern">
              <h3 class="heading">
                <span>Validators.pattern</span>
                <a href="#validators-pattern">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The <strong>pattern</strong> validator will check if the value matches a regular expresion given in <code>customParams.pattern</code>                option. This regular expression can be either a
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>                instance or a string. It's important to mention that <code><strong>flags</strong></code> in string patterns
                are not supported.
              </p>
              <p>
                If you need flags in string patterns you can use the
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp constructor</a>.
              </p>
              <p>
                <strong>Important!</strong> You must always provide<code>customParams.pattern</code>. In case it is not provided
                an error will be thrown in the <code>catch</code> block of the returned promise.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const CODE_PATTERN = /^LC\d{3}$/; // or "^LC\d{3}$"
const validationConstraints = {
  fields: {
    code: [
      {
        validator: Validators.pattern,
        customParams: { pattern: CODE_PATTERN }
      }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(null, 'code', 'LC001')
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'PATTERN'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'code', '003a')
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'PATTERN'
    console.log(validationResult.errorMessage);
    // 'Please provide a valid format.'
  });</code></pre>
            </article>
            <article id="validators-email">
              <h3 class="heading">
                <span>Validators.email</span>
                <a href="#validators-email">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>
                The email validator will check if the given string value is a valid email address. LcFormValidation's email validator uses
                a RegExp provided by <a href="//emailregex.com">emailregex.com</a> that follows RFC 5322
                Official Standard since email address validation is hard to implement and there is not an unique source of
                truth. If this email validator doesn't meet your requirements you can write your
                <a href="#custom-validators">custom validator</a>.
              </p>
              <p>
                Note: empty values such <code>null</code> or <code>undefined</code> will be marked as valid values. If you
                need to check for non-empty values you may use this validator along with
                <a href="#validators-required">required</a> validator.
              </p>
              <pre class="snippet"><code class="language-js">import { createFormValidation, Validators } from 'lc-form-validation';

const viewModel = null;
const validationConstraints = {
  fields: {
    email: [
      { validator: Validators.email }
    ]
  }
};

const formValidation = createFormValidation(validationConstraints);

formValidation
  .validateField(viewModel, 'email', 'johndoe@example.com')
  .then(validationResult => {
    console.log(validationResult.succeeded); // true
    console.log(validationResult.type); // 'EMAIL'
    console.log(validationResult.errorMessage); // ''
  });

formValidation
  .validateField(null, 'email', 'invalidValue')
  .then(validationResult => {
    console.log(validationResult.succeeded); // false
    console.log(validationResult.type); // 'EMAIL'
    console.log(validationResult.errorMessage);
    // 'Please enter a valid email address.'
  });</code></pre>
            </article>
          </section>
          <section id="custom-validators">
            <h2 class="heading">
              <span>Implementing a custom validation</span>
              <a href="#custom-validators">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h2>
            <article>
              <h4>Implementing a field validator</h4>
              <p>
                This validator function will be provided with the value of the field, the entire view model and a fixed plain object with
                extra parameters. Your field validator must always return a FieldValidationResult (or a wrapper promise for
                async validations) that returns a FieldValidationResult, that is, a plain object with three properties:
              </p>
              <p>Your validator would look like this:</p>
              <pre class="snippet"><code class="lang-js">function myFooValidator(value, vm, customParams) {
  const isValid = value === 'foo';
  const errorMessage = 'You must provide a "foo" value';
  const validationResult = new FieldValidationResult();
  // You can create an empty object too

  validationResult.succeeded = isValid;
  validationResult.type = 'FOO';
  validationResult.errorMessage = isValid ? '' : errorMessage;
  return validationResult;
}
</code></pre>
              <p>Or like this for an async validator:</p>
              <pre class="snippet"><code class="lang-js">function myFooValidator(value, vm, customParams) {
  const errorMessage = 'You must provide a "foo" value';
  const validationResult = new FieldValidationResult();
  validationResult.type = 'ASYNC_FOO';

  return Promise.resolve(asyncFooValidator(value))
    .then(isValid => {
      validationResult.isValid = isValid;
      validationResult.errorMessage = errorMessage;
      return validationResult;
    })
    .catch(error => {
      validationResult.isValid = false;
      validationResult.errorMessage = errorMessage;
      return validationResult;
    });
}

function asyncFooValidator() {
  /*
    make some server calls and return a deferred
    object that returns true or false
  */
}
</code></pre>
            </article>
          </section>
          <section id="api">
            <h1 class="heading">
              <span>API</span>
              <a href="#api">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h1>
            <article id="FieldValidationResult">
              <h3 class="heading">
                <span>FieldValidationResult</span>
                <a href="#FieldValidationResult">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>FieldValidationResult is a simple class with three main properties:</p>
              <ul>
                <li>
                  <code>succeeded</code> <em>boolean</em> - The result of a validation constraint.
                </li>
                <li>
                  <code>type</code> <em>string</em> - A key to recognise the validation result when applied multiple validators
                  on a field.
                </li>
                <li>
                  <code>errorMessage</code> <em>string</em> - A message describing why the field did not get validated. This
                  field can be declared as empty for a successful validation.
                </li>
              </ul>
            </article>
            <article id="validateForm">
              <h3 class="heading">
                <span>FormValidation.validateForm(viewModel)</span>
                <a href="#validateForm">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
              <p>It validates the entire viewModel triggering all validations per field and globals previously defined in <code>validationConstraints</code>.
                Every field validations will be executed sequentially </p>
              <p>Returns a promise with a <a href="#FormValidationResult">FormValidationResult</a>.</p>
              <pre class="snippet"><code class="language-js">formValidation
  .validateForm(viewModel)
  .then(validationResult => {
    // handle validation global validation result
  })
  .catch(error => {
    // handle error
  });</code></pre>
            </article>
            <article id="#validateField">
              <h3 class="heading">
                <span>validateField</span>
                <a href="#validateField">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
            </article>
            <article id="#isValidationInProgress">
              <h3 class="heading">
                <span>isValidationInProgress</span>
                <a href="#isValidationInProgress">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
            </article>
            <article id="#isFormPristine">
              <h3 class="heading">
                <span>isFormPristine</span>
                <a href="#isFormPristine">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
            </article>
            <article id="#isFormDirty">
              <h3 class="heading">
                <span>isFormDirty</span>
                <a href="#isFormDirty">
                  <img src="img/link.svg" alt="(link this)">
                </a>
              </h3>
            </article>
          </section>
          <section id="changelog">
            <h3 class="heading">
              <span>Change Log</span>
              <a href="#changelog">
                <img src="img/link.svg" alt="(link this)">
              </a>
            </h3>
          </section>
        </main>
        <aside class="col-md-3">
          <nav class="main-menu hidden-sm hidden-xs scrollspy" data-toggle="affix" data-spy="affix" data-offset-top="240">
            <ul class="nav">
              <li>
                <a href="#introduction">Introduction</a>
                <ul class="nav">
                  <li><a href="#why">Why LcFormValidation</a></li>
                  <li><a href="#approach">Approach</a></li>
                </ul>
              </li>
              <li><a href="#download">Download</a></li>
              <li><a href="#installation">Installation</a></li>
              <li>
                <a href="#get-started">Get started</a>
                <ul class="nav">
                  <li><a href="#overview">Overview</a></li>
                  <li><a href="#validation-constraint">Validation constraint</a></li>
                  <li><a href="#validating-form">Validating form</a></li>
                </ul>
              </li>
              <li>
                <li><a href="#validators">Validators</a></li>
                <ul class="nav">
                  <li><a href="#validators-required">required</a></li>
                  <li><a href="#validators-minLength">minLength</a></li>
                  <li><a href="#validators-maxLength">maxLength</a></li>
                  <li><a href="#validators-pattern">pattern</a></li>
                  <li><a href="#validators-email">email</a></li>
                </ul>
                <li><a href="#custom-validators">Custom validator</a></li>
              </li>
              <li>
                <a href="#api">API</a>
                <ul class="nav">
                  <li><a href="#FieldValidationResult">FieldValidationResult</a></li>
                  <li><a href="#FormValidationResult">FormValidationResult</a></li>
                  <li>
                    <a>FormValidation</a>
                    <ul class="nav">
                      <li><a href="#validateForm">validateForm</a></li>
                      <li><a href="#validateField">validateField</a></li>
                      <li><a href="#isValidationInProgress">isValidationInProgress</a></li>
                      <li><a href="#isFormPristine">isFormPristine</a></li>
                      <li><a href="#isFormDirty">isFormDirty</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><a href="#changelog">Change Log</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prism.js" async></script>
    <script src="js/index.js"></script>
  </body>
</html>
